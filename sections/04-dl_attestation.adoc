
[#main]
== DL Attestation

A Digital Ledger can be viewed as an untrusted logger, serving a number of
clients who wish to store their events in the log, and
kept honest by a number of auditors who will challenge
the logger to prove its correct behavior <<CrosbyWallach>>.

A Merkle Tree data structure allow to accomplish this very efficently aggregating
many requests and submitting to the log periodically just the root digest of the tree.
This log is built as an hash chain (aka blockchain) of small blocks of data.
With this conditions the entire chain can be shared and mantained
by a large number of nodes, becoming a distributed system.

In a permissioned DL the number of nodes can be small enought to permit a quick
syncronization to reach the consensus about the state of the chain.
Instead in a permissionless DL the large number of nodes introduces a relevant delay
to reach the consensus.

In the case of Bitcoin the consensus is reached statistically.
Usually in an elapsed mean time of one hour six new blocks are added to the chain.
A block of data that has been added before the last six blocks
is considered practically immutable.
This is motivated by the high computational power that would be required to rewrite the chain.

As a result of this scenario the time elapsed - from the request of aggregation of a digest
to the proof consolidated inside the DL - could amount to more than one hour.

This is the motivation to distinguish from a *promise* of attestation and a *proof* of attestation.
An Aggregation Server generally can provide only a promise to timestamping the digest of the client
in the DL. After the aggregation is completed and the root hash of the Merkle Tree has been
recorded in a block of the chain, the promise is still not yet comnfirmed,

Only when the consensus on that block is reached - statistically, in the Bitcoin case - then
the attestation could be consideed a proof, stored and provided by a Calendar Server.

For simplicity of implementation, the Aggregation and the Calendar Server can be a uniq instance.

The DLA data structure is out of scope of this specification. Any Calendar Server can define his application protocol and data structure. For this specification the DLA is considered as pure data.

== DL Extension

A DL Extension is a data structure included in a TST
using the extensions field defined in <<RFC3161,2.4.1 of>>.

A DL Extension SHALL contain:

- an OID registered at IANA that uniquely identify the Calendar protocol used
- at least one Calendar Token

A DL Extensionn MAY contain also an inner TST previously obtained.
// @riba TODO: come si distingue??? non conviene avere due OID diversi???

=== Parallel Scheme

If there is no an inner TST, the data timestamped by the DLA is
the same data that will be signed by the TSA without the Calendar Token itself.

In this scheme the DLA provide a timestamp of the same data timestamped by outer TST,
that can be useful to proof their existence, but cannot proof the existence
of the TST itself prior to a specific point in time.

This limit is due to the fact that also the TST Extension has to be be signed by the TSA.

=== Serial Scheme

The inner TST, if present, is the data timestamped by the DLA.

In this scheme the DLA provide a proof of the existence of the inner TST
prior to a specific point in time.

The Serial Scheme is recommended to protect in the long-term also the validity of a TST,
not just to proof the existence of the data timestamped with a TST.

The TSA generates the inner TST, commit to the Calendar Server the request to timestamp
on the DL the digest of the inner TST, then generate the outer TST including
in the DL Extension the Calendar Token and the inner TST.

In this scenario it is also possible to upgrade later the TST. When the TSA receive
a request containing a DL Extension, it can check the Calendar Token contained and,
if there is a pending promise inside, it can request the Calendar Server to get the
proof to include it in the new TST.

=== Calendar Token

A Calendar Token SHALL contain:

- the version of the DLA
// FIXME: non serve a distinguere ANCHE tra singola e doppia marca
- at least one DLA, that is a timestamping promise OR a timestamp proof
- a string that uniquely identify the DL used by the Calendar Server
// da dove viene? lo dichiara il Calendar?

A Calendar Token MAY contain for each DLA that is a promise
the URI to a document defining the promise policies.

// @cisba TODO: definire meglio le policies della promessa?

=== OpenTimestamps

It has to be expressly clarified that this specification does not intend to be restricted
to the Bitcoin and OpenTimestamps implementations of DL and Calendar general solutions.
It will just be taken as the starting point for future enhancements and evolutive proposal.

We simply considered that:

* Bitcoin is the first DL implementation and it is still working since January 2009
* Bitcoin is a permissionless DL, with a significant delay necessary to reach a consensus,
so a standard made to fit for it will be more general and easly usable also for others DL,
also permissioned, eventually providing the proof syncronously, and so not requiring a promise
* the OpenTimestamps software is licensed with the GNU LGPL Version 3, the server is written in python
and clients are available in python, java, javascript and rust
* OpenTimestamps is a proven working solution timestamping on the Bitcoin DL
// @cisba TODO: since...
* OpenTimestamps is potentially DL-agnostic, in fact an experimental version stamping
on the Ethereum DL has been arount for a while
* OpenTimestamps Calendars are currently available for free to the public thanks to donors

For all this reasons the choice of Bitcoin as DL and OpenTimestamps as Calendar seem
the favourite example do define an open standard of DL Attestation extending TST validity.

